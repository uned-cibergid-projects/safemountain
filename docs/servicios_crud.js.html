<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Source: servicios/crud.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-modules"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-ciber_apks_api.html">ciber/apks_api</a></div><div class="sidebar-section-children"><a href="module-ciber_tpls_api.html">ciber/tpls_api</a></div><div class="sidebar-section-children"><a href="module-ciber_versions_api.html">ciber/versions_api</a></div><div class="sidebar-section-children"><a href="module-modAppCollector_apks.html">modAppCollector/apks</a></div><div class="sidebar-section-children"><a href="module-modAppCollector_tpls.html">modAppCollector/tpls</a></div><div class="sidebar-section-children"><a href="module-modAppCollector_versions.html">modAppCollector/versions</a></div><div class="sidebar-section-children"><a href="module-modelos_appCollector.html">modelos/appCollector</a></div><div class="sidebar-section-children"><a href="module-servicios_crud.html">servicios/crud</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">servicios_crud.js</h1></header><article><pre class="prettyprint source lang-js"><code>/** 
 * @module servicios/crud
 * 
 * @description Funciones CRUD para interactuar con diferentes modelos y colecciones en la base de datos.
 */

'use strict'
const debug = require('debug')('gcono:crud');
debug('CRUD Versión: 3.0.1')

const {colecciones} = require('./modelos/appCollector.model')

module.exports = {
    contar: contar, 
    leerId:leerId,
    leerCampo:leerCampo,
    nuevo:nuevo,
    modificarId:modificarId,
    modificarUno: modificarUno,
    borrar:borrar,
    borrarVarios:borrarVarios,
    modificarVarios:modificarVarios,
    modificarArray:modificarArray,
    borrarArray:borrarArray,
    nuevoArray:nuevoArray,
    insertarVarios:insertarVarios,
    grabarLog:grabarLog
}

/**
 * @description Cuenta documentos en la colección especificada basándose en criterios de búsqueda.
 * 
 * @function contar
 * @param {Object} [filtro={}] - Criterios de búsqueda para contar documentos.
 * @param {string} coleccion - Nombre de la colección en la que se realizará la operación.
 * @returns {Promise&lt;Object>} Una promesa que resuelve con el número de documentos contados y el estado de la operación.
 * @throws {Error} Si ocurre un error durante la operación, lanza un error con detalles del contexto.
 */
function contar(filtro={}, coleccion){
    let promesa = (resolve,reject) =>{

        const MODELO = colecciones[coleccion].modelo;

        MODELO.countDocuments(filtro)
            .then(cuenta => {
                resolve({ok:true, mensaje:coleccion, datos:cuenta})
            })
            .catch(err => {
                err.ok= true;
                err.coleccion = coleccion;
                err.accion = 'contar';
                reject(err)
            });

    }
    return new Promise(promesa)
}

/**
 * @description Recupera un documento por su ID único.
 * 
 * @function leerId
 * @param {string} id - El identificador único del documento a recuperar.
 * @param {string} coleccion - Nombre de la colección en la que se realizará la búsqueda.
 * @returns {Promise&lt;Object>} Una promesa que resuelve con el documento recuperado y el estado de la operación.
 * @throws {Error} Si ocurre un error durante la operación o el documento no se encuentra, lanza un error con detalles del contexto.
 */
function leerId(id, coleccion){
    let promesa = (resolve,reject) =>{
        const MODELO = colecciones[coleccion].modelo;
        MODELO.findById(id).lean()
            .then(registro =>{
                if (!registro){
                    resolve({ok:false, mensaje:'Colección: '+coleccion+'. No existe el registro id='+id,datos:''})
                }else{
                    resolve({ok:true, mensaje:coleccion, datos:registro})
                }
            })
            .catch(err => {
                err.ok= true;
                err.coleccion = coleccion;
                err.accion = 'leerId';
                reject(err)
            });
    }
    return new Promise(promesa)
}

/**
 * @description Recupera documentos basándose en criterios específicos.
 * 
 * @function leerCampo
 * @param {Object} opciones - Opciones para la consulta, incluyendo criterios de búsqueda, ordenamiento, campos seleccionados, límite y paginación.
 * @param {Object} [opciones.filtro] - Criterios de búsqueda como pares clave-valor.
 * @param {Object} [opciones.orden] - Especificación del orden de los resultados.
 * @param {Object} [opciones.campos] - Campos a seleccionar en los documentos.
 * @param {number} [opciones.limite] - Número máximo de documentos a recuperar.
 * @param {number} [opciones.skip] - Número de documentos a omitir para paginación.
 * @param {string} coleccion - Nombre de la colección en la que se realizará la consulta.
 * @returns {Promise&lt;Object>} Una promesa que resuelve con los documentos recuperados y el estado de la operación.
 * @throws {Error} Si ocurre un error durante la operación, lanza un error con detalles del contexto.
 */
function leerCampo(opciones, coleccion){
    let promesa = (resolve,reject) =>{
        let filtro = {};
        let campos = {};
        let orden = {};
        let limite = 0;
        let skip = 0;

        if(opciones.hasOwnProperty('filtro') &amp;&amp; opciones.filtro != null &amp;&amp; opciones.filtro !='') filtro = opciones.filtro;
        if(opciones.hasOwnProperty('orden') &amp;&amp; opciones.orden != null &amp;&amp; opciones.orden !='') orden = opciones.orden;
        if(opciones.hasOwnProperty('campos') &amp;&amp; opciones.campos != null &amp;&amp; opciones.campos !='') campos = opciones.campos;
        if(opciones.hasOwnProperty('limite') &amp;&amp; opciones.limite != null &amp;&amp; opciones.limite !='') limite = opciones.limite;
        if(opciones.hasOwnProperty('skip') &amp;&amp; opciones.skip != null &amp;&amp; opciones.skip !='') skip = opciones.skip;
        const MODELO = colecciones[coleccion].modelo;
        if(limite== 1){
            MODELO.findOne(filtro).lean()
                .sort(orden)
                .select(campos)
                .then(registro => {
                    if (!registro) {
                        resolve({
                            ok:false, 
                            mensaje:`${coleccion} Lectura: No encontrado búsqueda= ${JSON.stringify(opciones.filtro).replace(/\"/g,"")}`, 
                            datos:[]
                        });
                    }else{
                        resolve({ok:true, mensaje:coleccion, datos:registro})
                    }
                })
                .catch(err => {
                    err.ok= true;
                    err.coleccion = coleccion;
                    err.accion = 'leerCampo';
                    reject(err)
                });
        }else{
            MODELO.find(filtro).lean()
                .sort(orden)
                .limit(limite)
                .skip(skip)
                .select(campos)
                .then(registros => {
                    if (registros.length&lt;1) {
                        resolve({
                            ok:false, 
                            mensaje:`${coleccion} Lectura: No encontrado búsqueda= ${JSON.stringify(opciones.filtro).replace(/\"/g,"")}`,
                            datos:[]
                        })
                    }else {
                        resolve({ok:true, mensaje:coleccion, contar:registros.length, datos:registros})
                    }
                })
                .catch(err => {
                    err.ok= true;
                    err.coleccion = coleccion;
                    err.accion = 'leerCampo';
                    reject(err)
                });
        }  
    }
    return new Promise(promesa)
}

/**
 * @description Inserta un nuevo documento en la colección especificada.
 * 
 * @function nuevo
 * @param {Object} reg - Datos del nuevo documento a insertar.
 * @param {string} coleccion - Nombre de la colección en la que se realizará la operación.
 * @param {Object} [opciones] - Opciones adicionales como tipo, mensaje y acción.
 * @param {string} [opciones.tipo="log"] - Tipo de operación.
 * @param {string} [opciones.mensaje=""] - Mensaje adicional para el log.
 * @param {string} [opciones.accion="nuevo"] - Acción realizada.
 * @returns {Promise&lt;Object>} Una promesa que resuelve con el documento insertado y el estado de la operación.
 * @throws {Error} Si ocurre un error durante la operación, lanza un error con detalles del contexto.
 */
function nuevo(reg, coleccion, {tipo="log", mensaje="", accion="nuevo"}= {}){    
    let promesa = async (resolve,reject) =>{
        try{
            const MODELO = colecciones[coleccion].modelo;
            const nuevoRegistro = await MODELO.create(reg)

            if (!nuevoRegistro){
                const err = new Error('Error no se pudo crear el nuevo Registro');
                err.ok= true;
                err.coleccion = coleccion;
                err.accion = accion;
                err.mensaje = `No se pudo crear el nuevo Registro`;
                reject(err)
            }else{
                resolve({
                    ok:true, 
                    // mensaje: coleccion + '. Nuevo nuevoRegistro creado. id= '+ nuevoreg._id,
                    mensaje: coleccion + '. Nuevo Registro creado',
                    datos: nuevoRegistro.toObject()
                });
                if(coleccion != 'Log') {
                    let log ={
                        idgcono: idGcono,
                        coleccion: coleccion,
                        accion: accion,
                        ok: 201,
                        id_: nuevoRegistro._id.toString()
                    }; 
                    grabarLog(log)
                };
            } 
        }catch(err){
            err.coleccion = coleccion;
            err.accion = accion;
            reject(err)
        }; 
    }
    return new Promise(promesa)
}

/**
 * @description Modifica un documento en la colección especificada por su ID.
 * 
 * @function modificarId
 * @param {string} id - Identificador único del documento a modificar.
 * @param {Object} reg - Nuevos datos para actualizar el documento.
 * @param {string} coleccion - Nombre de la colección en la que se realizará la operación.
 * @param {Object} [options] - Opciones adicionales como tipo, mensaje y acción.
 * @param {string} [options.tipo="log"] - Tipo de operación.
 * @param {string} [options.mensaje=""] - Mensaje adicional para el log.
 * @param {string} [options.accion="modificar"] - Acción realizada.
 * @returns {Promise&lt;Object>} Una promesa que resuelve con el documento modificado y el estado de la operación.
 * @throws {Error} Si ocurre un error durante la operación, lanza un error con detalles del contexto.
 */
function modificarId(id, reg, coleccion, {tipo="log", mensaje="", accion="modificar"}= {}){
    let promesa = async (resolve,reject) =>{
        try{
            const MODELO = colecciones[coleccion].modelo;
            delete reg._id;
            delete reg.f_modificacion;

            const registro = await MODELO.findOneAndUpdate({_id:id}, reg, {new:true})
            
            if (!registro){
                const err = new Error('Error no existe el registro id= '+id);
                err.ok= true;
                err.coleccion = coleccion;
                err.accion = accion;
                err.mensaje = `No existe el registro id= ${id}`;
                reject(err)
            }else {
                // debug(registro.toObject())
                const salida = registro.toObject()
                resolve({ok:true, mensaje:coleccion+'. Modificado registro id='+id, datos:registro.toObject()});

                if(coleccion != 'Log') {
                    let log ={
                        idgcono: idGcono,
                        coleccion: coleccion,
                        accion: accion ,
                        ok: 200,
                        id_: id.toString(),
                        mensaje: ''
                    }; 
                    grabarLog(log);
                }
            }            
 
        }catch(err){
            err.coleccion = coleccion;
            err.accion = accion;
            reject(err)
        }; 
    }
    return new Promise(promesa)
}

/**
 * @description Modifica un documento en la colección especificada basado en criterios de búsqueda.
 * 
 * @function modificarUno
 * @param {Object} filtro - Criterios para identificar el documento a modificar.
 * @param {Object} reg - Nuevos datos para actualizar el documento.
 * @param {string} coleccion - Nombre de la colección en la que se realizará la operación.
 * @param {Object} [options] - Opciones adicionales como tipo, mensaje y acción.
 * @param {string} [options.tipo="log"] - Tipo de operación.
 * @param {string} [options.mensaje=""] - Mensaje adicional para el log.
 * @param {string} [options.accion="modificar"] - Acción realizada.
 * @returns {Promise&lt;Object>} Una promesa que resuelve con el documento modificado y el estado de la operación.
 * @throws {Error} Si ocurre un error durante la operación, lanza un error con detalles del contexto.
 */
function modificarUno(filtro, reg, coleccion, {tipo="log", mensaje="", accion="modificar"}= {}){
    let promesa = async (resolve,reject) =>{
        try{
            const MODELO = colecciones[coleccion].modelo;
            delete reg._id;
            delete reg.f_modificacion;
            
            const registro = await MODELO.findOneAndUpdate(filtro, reg, {new:true}).lean()
            
            if (!registro){
                reject({ok:false, message: coleccion + '. Modificar: No se encuentran registros en la búsqueda'+ JSON.stringify(filtro).replace(/\"/g,""), coleccion: coleccion, accion:'modificar'})
            }else{
                
                resolve({ok:true, mensaje:`${coleccion}. Modificado en búsqueda: ${JSON.stringify(filtro).replace(/\"/g,"")}`, datos:registro})
                
                if(coleccion != 'Log') {
                    let log ={
                        idgcono: idGcono,
                        coleccion: coleccion,
                        accion: 'modificar',
                        ok: 200,
                        id_: registro._id.toString(),
                        mensaje: JSON.stringify(filtro).replace(/\"/g,""),
                        tipo: tipo
                    }; 
                    grabarLog(log)
                }
            }
     
        }catch(err){
            err.coleccion = coleccion;
            err.accion = 'modificar';
            reject(err)
        };   
    }
    return new Promise(promesa)
}

/**
 * @description Elimina un documento de la colección especificada por su ID.
 * 
 * @function borrar
 * @param {string} id - Identificador único del documento a eliminar.
 * @param {string} coleccion - Nombre de la colección en la que se realizará la operación.
 * @param {Object} [options] - Opciones adicionales como tipo, mensaje y acción.
 * @param {string} [options.tipo="log"] - Tipo de operación.
 * @param {string} [options.mensaje=""] - Mensaje adicional para el log.
 * @param {string} [options.accion="borrar"] - Acción realizada.
 * @returns {Promise&lt;Object>} Una promesa que resuelve con el resultado de la operación de eliminación.
 * @throws {Error} Si ocurre un error durante la operación, lanza un error con detalles del contexto.
 */
function borrar(id, coleccion, {tipo="log", mensaje="", accion="borrar"}= {}){
    let promesa = async (resolve,reject) =>{
        try{
            const MODELO = colecciones[coleccion].modelo;
            const resultado = await MODELO.deleteOne({_id:id})
            
            if(resultado.deletedCount &lt; 1){
                resolve({ok:false, mensaje: `Borrado ${coleccion}. No encontrado id: ${id}`, datos:resultado})
            }else {
                resolve({ok:true, mensaje: `Borrado ${coleccion}. id: ${id}`, datos:resultado});

                if(coleccion != 'Log') {
                // no creo log de las operaciones realizadas sobre la colección Log. 
                    let log ={
                        idgcono: idGcono,
                        coleccion: coleccion,
                        accion: 'borrar',
                        ok: 200,
                        id_: id.toString(),
                        mensaje: '',
                        tipo: tipo
                    };
                    grabarLog(log);
                }
            }            
        }catch(err){
            err.coleccion = coleccion;
            err.accion = accion;
            reject(err)
        };  
    }
    return new Promise(promesa)
}

/**
 * @description Elimina múltiples documentos de la colección especificada basándose en criterios de búsqueda.
 * 
 * @function borrarVarios
 * @param {Object} filtro - Criterios para identificar los documentos a eliminar.
 * @param {string} coleccion - Nombre de la colección en la que se realizará la operación.
 * @param {Object} [options] - Opciones adicionales como tipo, mensaje y acción.
 * @param {string} [options.tipo="log"] - Tipo de operación.
 * @param {string} [options.mensaje=""] - Mensaje adicional para el log.
 * @param {string} [options.accion="borrarVarios"] - Acción realizada.
 * @returns {Promise&lt;Object>} Una promesa que resuelve con el resultado de la operación de eliminación.
 * @throws {Error} Si ocurre un error durante la operación, lanza un error con detalles del contexto.
 */
function borrarVarios(filtro, coleccion, {tipo="log", mensaje="", accion="borrarVarios"}= {}){
    let promesa = async (resolve,reject) =>{
        try{
            const MODELO = colecciones[coleccion].modelo;
            const resultado = await MODELO.deleteMany(filtro)

            if(resultado.deletedCount &lt; 1){
                resolve({ok:false, mensaje: `Borrar ${coleccion} => No encontrado en búsqueda: ${JSON.stringify(filtro).replace(/\"/g,"")}`, datos:resultado})
            }else {
                resolve({ok:true, mensaje: `Borrados ${resultado.deletedCount} ${coleccion} de búsqueda: ${JSON.stringify(filtro).replace(/\"/g,"")}`, datos:resultado})

                if(coleccion != 'Log') {
                    let log ={
                        idgcono: idGcono,
                        coleccion: coleccion,
                        accion: 'borrar',
                        ok: 200,
                        id_:'0',                    
                        mensaje: `Borrados: ${resultado.deletedCount} en búsqueda: ${JSON.stringify(filtro).replace(/\"/g,"")}`,
                        tipo: tipo
                    };
                    grabarLog(log);
                }
            }            
        }catch(err){
            err.coleccion = coleccion;
            err.accion = accion;
            reject(err)
        };              
    }
    return new Promise(promesa)
}

/**
 * @description Modifica múltiples documentos en la colección especificada basándose en criterios de búsqueda.
 * 
 * @function modificarVarios
 * @param {Object} buscar - Criterios para identificar los documentos a modificar.
 * @param {Object} actualizacion - Datos que se usarán para actualizar los documentos encontrados.
 * @param {string} coleccion - Nombre de la colección en la que se realizará la operación.
 * @param {Object} [options] - Opciones adicionales como tipo, mensaje y acción.
 * @param {string} [options.tipo="log"] - Tipo de operación.
 * @param {string} [options.mensaje=""] - Mensaje adicional para el log.
 * @param {string} [options.accion="modificarVarios"] - Acción realizada.
 * @returns {Promise&lt;Object>} Una promesa que resuelve con el resultado de la operación de modificación.
 * @throws {Error} Si ocurre un error durante la operación, lanza un error con detalles del contexto.
 */
function modificarVarios(filtro, actualizacion, coleccion, {tipo="log", mensaje="", accion="modificarVarios"}= {}){
    let promesa = async (resolve,reject) =>{
        try{
            const MODELO = colecciones[coleccion].modelo;
            const resultado = await MODELO.updateMany(filtro, actualizacion)
                if (resultado.n==0) {
                    resolve({ok:false, mensaje: coleccion +'. Modificar: No se encuentran registros en la búsqueda= '+ JSON.stringify(filtro).replace(/\"/g,""), datos:''});
                } else resolve({ok:true, mensaje:coleccion+'. Modificados (' + resultado.n + ' registros)', datos:resultado});
                if(coleccion != 'Log') {
                    let log ={
                        idgcono: idGcono,
                        coleccion: coleccion,
                        accion: 'modificarVarios',
                        ok: 201,
                        id_:"0",
                        mensaje: `Modificados: ${resultado.length} en búsqueda: ${JSON.stringify(filtro).replace(/\"/g,"")}`,
                        tipo: tipo
                    }; 
                    grabarLog(log);
                }
        }catch(err){
            err.coleccion = coleccion;
            err.accion = accion;
            reject(err)
        }; 
    }
    return new Promise(promesa)
}

/**
 * @description Inserta múltiples documentos en la colección especificada.
 * 
 * @function insertarVarios
 * @param {Array&lt;Object>} registros - Array de documentos a insertar.
 * @param {string} coleccion - Nombre de la colección en la que se realizará la operación.
 * @param {Object} [options] - Opciones adicionales como tipo, mensaje y acción.
 * @param {string} [options.tipo="log"] - Tipo de operación.
 * @param {string} [options.mensaje=""] - Mensaje adicional para el log.
 * @param {string} [options.accion="insertarVarios"] - Acción realizada.
 * @returns {Promise&lt;Object>} Una promesa que resuelve con el resultado de la operación de inserción.
 * @throws {Error} Si ocurre un error durante la operación, lanza un error con detalles del contexto.
 */
function insertarVarios(registros, coleccion, {tipo="log", mensaje="", accion="insertarVarios"}= {}){
    let promesa = async (resolve, reject)=>{
        try{
            const MODELO = colecciones[coleccion].modelo;
            const docs = await MODELO.insertMany(registros)
            resolve({
                ok:true,
                mensaje: coleccion+'. Insertar: '+registros.length+' registros',
                datos: docs.map(reg=> (reg.toObject()))
            })
                
            if(coleccion != 'Log') {
                let log ={
                    idgcono: idGcono,
                    coleccion: coleccion,
                    accion: 'insertarVarios',
                    ok: 201,
                    id_:'0',
                    mensaje: `Insertar varios: ${registros.length}`,
                    tipo: tipo
                }; 
                grabarLog(log);
            }
        }catch(err){
            err.coleccion = coleccion;
            err.accion = accion;
            reject(err)
        }; 
    }
    return new Promise(promesa);
};

/**
 * @description Modifica múltiples documentos en la colección basándose en un array de registros.
 * 
 * @function modificarArray
 * @param {Array&lt;Object>} array - Array de registros a modificar.
 * @param {string} coleccion - Nombre de la colección en la que se realizará la operación.
 * @param {Object} [options] - Opciones adicionales como tipo, mensaje y acción.
 * @param {string} [options.tipo="log"] - Tipo de operación.
 * @param {string} [options.mensaje=""] - Mensaje adicional para el log.
 * @param {string} [options.accion="modificarArray"] - Acción realizada.
 * @returns {Promise&lt;Object>} Una promesa que resuelve con el resultado de la operación de modificación.
 * @throws {Error} Si ocurre un error durante la operación, lanza un error con detalles del contexto.
 */
function modificarArray(array, coleccion, {tipo="log", mensaje="", accion="modificar"}= {}){
    let promesa = (resolve,reject) =>{
        let promiseArray = array.map(item => () =>{
            modificarId(item._id, item, coleccion, idGcono)
        })
        Promise.all(promiseArray.map(f => f()))
            .then(modificado => {
                resolve({
                    ok:true,
                    mensaje: 'modificado',
                    datos: ''
                })
                if(coleccion != 'Log') {
                    let log ={
                        idgcono: idGcono,
                        coleccion: coleccion,
                        accion: 'modificarArray',
                        ok: 201,
                        id_:'0',
                        mensaje: `Modificados array: ${modificado.length}`,
                        tipo: tipo
                    }; 
                    grabarLog(log);
                }
            })
            .catch(err => {
                err.ok= true;
                err.coleccion = coleccion;
                err.accion = 'modificarArray';
                reject(err)
            })
    }
    return new Promise(promesa)
}

/**
 * @description Elimina múltiples documentos en la colección basándose en un array de IDs.
 * 
 * @function borrarArray
 * @param {Array&lt;Object>} array - Array de documentos a eliminar.
 * @param {string} coleccion - Nombre de la colección en la que se realizará la operación.
 * @param {Object} [options] - Opciones adicionales como tipo, mensaje y acción.
 * @param {string} [options.tipo="log"] - Tipo de operación.
 * @param {string} [options.mensaje=""] - Mensaje adicional para el log.
 * @param {string} [options.accion="borrarArray"] - Acción realizada.
 * @returns {Promise&lt;Object>} Una promesa que resuelve con el resultado de la operación de eliminación.
 * @throws {Error} Si ocurre un error durante la operación, lanza un error con detalles del contexto.
 */
function borrarArray(array, coleccion, {tipo="log", mensaje="", accion="borrar"}= {}){
    let promesa = (resolve,reject) =>{
        let promiseArray = array.map(item => () =>{
        borrar(item._id, coleccion, idGcono)
    })
        Promise.all(promiseArray.map(f => f()))
            .then(borrados => {
                resolve({
                    ok:true,
                    mensaje: 'borrado',
                    datos: ''
                })
                if(coleccion != 'Log') {
                    let log ={
                        idgcono: idGcono,
                        coleccion: coleccion,
                        accion: 'borrarArray',
                        ok: 201,
                        id_:'0',
                        mensaje: `Borrados array: ${borrados.length}`,
                        tipo: tipo
                    }; 
                    grabarLog(log);
                }
            })
            .catch(err => {
                err.ok= true;
                err.coleccion = coleccion;
                err.accion = 'borrarArray';
                reject(err)
            })
    }
    return new Promise(promesa)
}

/**
 * @description Inserta múltiples documentos en la colección basándose en un array de registros.
 * 
 * @function nuevoArray
 * @param {Array&lt;Object>} array - Array de documentos a insertar.
 * @param {string} coleccion - Nombre de la colección en la que se realizará la operación.
 * @param {Object} [options] - Opciones adicionales como tipo, mensaje y acción.
 * @param {string} [options.tipo="log"] - Tipo de operación.
 * @param {string} [options.mensaje=""] - Mensaje adicional para el log.
 * @param {string} [options.accion="nuevoArray"] - Acción realizada.
 * @returns {Promise&lt;Object>} Una promesa que resuelve con el resultado de la operación de inserción.
 * @throws {Error} Si ocurre un error durante la operación, lanza un error con detalles del contexto.
 */
function nuevoArray(array, coleccion, {tipo='log', mensaje='', accion="nuevo"}= {}){
    let promesa = (resolve,reject) =>{
        let promiseArray = array.map(item => () =>{
        nuevo(item, coleccion, idGcono)
    })
        Promise.all(promiseArray.map(f => f()))
            .then(nuevos => {
                resolve({
                    ok:true,
                    mensaje: 'nuevo',
                    datos: ''
                })
                if(coleccion != 'Log') {
                    let log ={
                        idgcono: idGcono,
                        coleccion: coleccion,
                        accion: 'nuevoArray',
                        ok: 201,
                        id_:'0',
                        mensaje: `Nuevos array: ${nuevos.length}`,
                        tipo: tipo
                    }; 
                    grabarLog(log);
                }
            })
            .catch(err => {
                err.ok= true;
                err.coleccion = coleccion;
                err.accion = 'nuevoArray';
                reject(err)
            })
    }
    return new Promise(promesa)
}

/**
 * @description Registra un log de operación en la colección correspondiente.
 * 
 * @function grabarLog
 * @param {Object} log - Objeto con los detalles del log.
 * @returns {Promise&lt;void>} Una promesa que se resuelve cuando el log es registrado exitosamente.
 * @throws {Error} Si ocurre un error durante la operación, lanza un error con detalles del contexto.
 */
async function grabarLog(log){
    try{
        const MODELO = colecciones['Log'].modelo;
        const nuevoReg = await MODELO.create(log)
        return
    }catch(err){
        err.coleccion = 'Log';
        err.accion = 'nuevo';
        return err
    }; 
}</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><div class="mobile-nav-links"></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-modules"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-ciber_apks_api.html">ciber/apks_api</a></div><div class="sidebar-section-children"><a href="module-ciber_tpls_api.html">ciber/tpls_api</a></div><div class="sidebar-section-children"><a href="module-ciber_versions_api.html">ciber/versions_api</a></div><div class="sidebar-section-children"><a href="module-modAppCollector_apks.html">modAppCollector/apks</a></div><div class="sidebar-section-children"><a href="module-modAppCollector_tpls.html">modAppCollector/tpls</a></div><div class="sidebar-section-children"><a href="module-modAppCollector_versions.html">modAppCollector/versions</a></div><div class="sidebar-section-children"><a href="module-modelos_appCollector.html">modelos/appCollector</a></div><div class="sidebar-section-children"><a href="module-servicios_crud.html">servicios/crud</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>